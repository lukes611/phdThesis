\begin{savequote}[8cm]
  ``I have not failed. I've just found 10,000 ways that won't work.''
  \qauthor{Thomas Edison}
\end{savequote}
\makeatletter
\chapter{Methodology}

\section{Introduction}

To answer the proposed research question and realize the primary goal of improving storage, quantitative quality and perceptual quality of 3D models, a novel lossy mesh codec was conceived. This method, termed the Shade-Octree (SOT), was developed using techniques from hierarchical image compression research. A survey of these methods is presented in section 3.2. Section 3.3 relates the SOT with other techniques and section 3.4 discusses the details of the SOT.

\section{Hierarchical Techniques}

\subsection{Quadtree Modification}
The QT, discussed in section 2.2.5, is a fundamental data structure in computer science. Many hierarchical techniques are based on it's decomposition and representation strategy. Varma \textit{et al.} \cite{Varma12Application} recently developed a variation of the QT which uses a bottom-up decomposition strategy combined with a polynomial leaf region representation. It is particularly suited to low bit rate compression and is proven to outperform JPEG in terms rate-distortion at low bit rates.

\subsection{The BSP Tree}

Radha \textit{et al.} \cite{Radha96Image} use a BSP tree to compress image data. Each leaf in the tree uses boundary lines to represent discrete polygonal regions in the image. Each boundary line is stored using its angle and orthogonal distance from the origin, an example is shown in figure \ref{QuadTreeBSPWedgeletExample}. Radha \textit{et al.} investigated the computation of these boundaries, compact representation of the tree and the role of quantization. The BSP is shown to outperform JPEG in terms of rate-distortion.

\subsection{The Wedgelet}

The Wedgelet, developed by Donoho \cite{Donoho99Wedgelets}, combines QT decomposition with the boundary line technique used in the BSP tree. Instead of using the average colour value to represent leaf regions, the quadrant is split in two and both sides are given a colour. The boundary line is stored using the orthogonal distance and angle values of the line, figure \ref{WedgeletExample} shows an example of a wedgelet quadrant. Each leaf node is like a small image which is split only once using the BSP technique. Wakin \textit{et al.} \cite{Wakin02Rate} further developed the technique by optimizing RD performance.

%\begin{figure}[!h]
%\centering
%\includegraphics[width=12cm]{images/ch1/WedgeletExample}
%\caption{Visualization of a Wedgelet node, Left: The sub-image to be represented by the Wedgelet leaf, Middle: The two values used to store the hyperplane, $d$, the orthogonal distance from the plane to the origin corner of the leaf node and $\theta$ the angle of the plane cut. Right: The corresponding leaf node representation for the Wedgelet.}
%\label{WedgeletExample}
%\end{figure}

\subsection{The Prune Quadtree and the Prune-Join Quadtree}

Motivated by the limitations of transform and wavelet codecs, Shukla \textit{et al.} \cite{Shukla05Rate} developed both, the Prune QT (PQ), and it's successor, the Prune-Join QT (PJQ). The PQ works by first performing QT decomposition on an image, then, in a bottom up fashion, each leaf is either kept, or pruned. This decision  is made using a lagrangian cost function. The PJQ extends the PQ by merging (joining) leaf nodes. This is done using the same lagrangian function involved in pruning the tree. For each leaf, the PJQ searches the tree for merge candidates. If the lagrangian cost of the merged leaves is smaller than the sum of their individual costs, they are merged together. Merged leaf nodes can be further joined with other leaves, this joining stops when merge decisions are no longer beneficial from a lagrangian cost perspective. The PJQ is shown to outperform the industry standard image codec, JPEG2000, in terms of rate-distortion.

%\begin{figure}[!h]
%\centering
%\includegraphics[width=12cm]{images/ch1/QuadTreeBSPWedgeletExample}
%\caption{Example of an image represented using hierarchical techniques: QT (left), BSP (middle) \& Wedgelet (right). (Image from \cite{Kassim09Hierarchical})}
%\label{QuadTreeBSPWedgeletExample}
%\end{figure}

\subsection{The ShadeTree}

The ShadeTree (ST), developed by Gonzalez \cite{Gonzalez07ShadeTree}, was designed to be an efficient image codec for embedded systems. This method is based on QT decomposition and uses four colour values to represent image blocks. These four colours approximate image blocks better than the QT as they are interpolated in from the corners, effectively shading in the block. The four leaf node colours are taken to be the corner values in the original image, in this way, multiple leaves can share corner colours which decreases storage space. The ST is shown to approach the performance of JPEG and outperforms the QT, it is also shown to be more computationally efficient than JPEG.

\subsection{The Quad-Binary-Tree}

Kassim \textit{et al.} \cite{Kassim09Hierarchical} developed a novel hierarchical technique called the Quad-Binary tree (QBT). This scheme was designed to be efficient and free of visual artefacts which are often produced by transform based codecs. The QBT is a hybrid codec, which combines the QT, wedgelet and BSP tree. It uses three different structures to represent nodes. These structures include: a quadrant (QT leaf node), a boundary line in a quadrant (wedgelet leaf node) and a polygonal region (BSP leaf node). The QBT stores control bits to identify which structure is used by each node. Huffman coding is used to compress node and control bit data. This method is shown to outperform the BSP tree, wedgelets and JPEG2000 in terms of rate-distortion. An example of this technique is shown in figure \ref{QBExample}. This method produces state of the art performance but is computationally inefficient.

\begin{figure}[!h]
\centering
\includegraphics[width=12cm]{images/ch1/QBExample}
\caption{QB tree example, QT (Quadtree), WL (Wedgelet) BSP (Binary Space Partitioning Tree). This is based on an image from \cite{Kassim09Hierarchical}}
\label{QBExample}
\end{figure}

\subsection{The Interpolating Leaf Quad Tree}

\begin{figure}[!h]
\centering
\includegraphics[width=12cm]{images/ch1/ILQTLeafNode}
\caption{ILQT Leaf Node}
\label{ILQTLeafNode}
\end{figure}

The Interpolating Leaf Quad Tree (ILQT) was developed by Lincoln \& Gonzalez \cite{Lincoln13Interpolating} to be an algorithmically simple, low bit rate image codec. The algorithm uses QT decomposition, and each leaf stores four colour values which are interpolated inwards from the corners. The four values are calculated as the average of the quadrants of the leaf node, figure \ref{ILQTLeafNode} illustrates this concept, where: A, B, C \& D are the four quadrants, the colour beneath each letter is the average colour of that particular region. Using these corner values allows the ILQT to approximate each block better than the ST and QT. The ILQT uses Dynamic Pulse Code Modulation to compress the tree. The colour data and the tree are then Huffman coded. The ILQT is shown to outperform JPEG, ST and the QT \cite{Varma12Application} at low bit rates. It is also shown to be more computationally efficient than these approaches. 

\section{Similarities With Existing Techniques}

As mentioned, the SOT compresses the polygonal mesh representation, this makes it comparable with mesh codecs  \cite{Siddiqui07Octree,Deering95Geometry,touma98triangle,Alliez01Valence-Driven}. It is also a lossy scheme with progressive capabilities, which also makes it comparable with progressive mesh codecs \cite{Hoppe96Progressive, Alliez01Progressive,Yemez03Multilevel, Schnabel06Otree-based}. The SOT performs a semi-regular sampling of the mesh. It then compresses the geometry data, which is used by the decoder to calculate triangles. This is similar to both the spectral and wavelet codecs \cite{Karni00Spectral, Khodakovsky00Progressive}. The SOT uses OT decomposition with the packed traversal method which further makes it comparable with hierarchical 3D model codecs. The SOT is most similar to the ST by Gonzalez \cite{Gonzalez07ShadeTree}, which is why it shares its name. Similarly to the ST the SOT merges neighbours to reduce storage requirements. The SOT also separates and multiplexes the compressed tree and attribute information, this technique was also employed by the ILQT method \cite{Lincoln13Interpolating}. The SOT also uses extra data stored in its leaf nodes to approximate the original data better, this technique is also used in both, the ST and ILQT.

\section{The Shade-Octree}

\subsection{Decomposition Strategy}

SOT decomposition is based on the OT, the mesh is first transformed into a $512\times 512\times 512$ bounding box. The tree uses the $MSE$ between the current leaf node and the original model as part of its leaf criterion. A cut-off variable we call the level of depth (LOD) is also used in the leaf criterion. This stops decomposition when a node reaches a maximum depth. Once the tree is formed, leaf nodes which cause spikes are pruned. These spikes are caused by an over fitting of the original model.

\subsection{Leaf Node Representation}

\begin{figure}[!h]
\centering
\includegraphics[width=12cm]{images/ch2/SOTDirections}
\caption{Three directions used to distinguish planes held by SOT leaves.}
\label{SOTDirections}
\end{figure}

Leaf nodes store a special type of plane which better approximates the original model. These planes require only a small amount of bits. To represent a plane, a 3 bit direction code is used to describe which axis the plane vertices run along. Figure \ref{SOTDirections} shows three leaf nodes, each one with a different direction code.  Notice that each plane vertex runs along the axis specified by the direction code. For example, the middle image has a y axis direction code, therefore, each vertex in the plan runs along the y-axis.

To understand how plane vertices are represented, the concept of the back-wall is described. The back-wall depends on the direction code of its corresponding leaf node. For example, if the vertices of the leaf node's plane ran along the y axis, then the back-wall includes any point within the leaf node which has a y axis distance of zero from the origin of the leaf node (the origin of the leaf node is the corner closest to the actual origin). Figure \ref{SOTDistances} labels the back-wall for an x axis direction code leaf node. Using this concept, the four vertices of a plane can be stored based on their x axis distance from the back-wall. Figure \ref{SOTDistances} uses arrows to highlight these distances. The SOT must store four distances per leaf node along with the direction code to encode each plane. 

\begin{figure}[!h]
\centering
\includegraphics[width=12cm]{images/ch2/SOTDistances}
\caption{4 distances used to store the geometry of planes inside SOT leaves.}
\label{SOTDistances}
\end{figure}

\subsection{Data Storage \& Compression}

Since the SOT compresses 3D model data, its bit representation affects efficiency. The tree is stored using a depth-first packed traversal method, where each node is represented by 8 bits. Each bit describes the existence of a particular sub-node. Before each 8 bit node is stored in the tree, a decision bit is used to tell the decoder whether the next node is a leaf node or not. This results in a smaller tree size, since leaf nodes require only one bit instead of eight. 

\begin{figure}[!h]
\centering
\includegraphics[width=12cm]{images/ch2/SOTSharing}
\caption{SOT Nodes, sharing plane vertices. Shared vertices are marked with a red dot.}
\label{SOTSharing}
\end{figure}

Directional and distance codes are encoded in separate files. The directional codes are stored using 2 bits, with the x-direction as $00_2$, the y-direction as $01_2$ and the z-direction as $10_2$, they are then compressed using packed decimal coding (bit to bit storage). The distance codes are stored using their distance relative to the back wall. These distances are limited to within three leaf node blocks of the back-wall. The distance values are then quantized to 8 bits. The SOT requires a total of 130 bits per leaf node. Plane vertices can be shared by neighbours if they are 6-connected and have the same direction code. The SOT saves storage space by only coding these vertices once. Figure \ref{SOTSharing} shows this property of the SOT, the red dots represent distance codes (plane vertices) which may be shared.

Once the tree, directional code and distance code files are computed, they are each Huffman coded separately. They are then multiplexed to form the final SOT file. A systems diagram of the SOT is shown in figures \ref{SOTCompressionScheme} and \ref{SOTDecompressionScheme}. Figure \ref{SOTCompressionScheme} shows the compression system. First, the SOT takes in an input mesh, then, using OT decomposition it checks whether the mesh within the current node can be represented by a plane, if not, subdivision continues, if so, the leaf node data is stored. 

\begin{figure}[!h]
\centering
\includegraphics[width=12cm]{images/ch2/SOTCompressionScheme}
\caption{The SOT Compression Scheme.}
\label{SOTCompressionScheme}
\end{figure}

The decoding system at the receiver is shown in figure \ref{SOTDecompressionScheme}. Here, the decoder iteratively moves through the tree, if a leaf is detected, it is decoded using the current position in the tree, as well as the directional and distance code files. This data is then stored in the output mesh. If no leaf node is encountered, the decoder continues moving through the tree until one is found, or the end of the file is reached.

\begin{figure}[!h]
\centering
\includegraphics[width=12cm]{images/ch2/SOTDecompressionScheme}
\caption{The SOT Decompression Scheme.}
\label{SOTDecompressionScheme}
\end{figure}

\subsection{Calculating Directional \& Distance Codes}

In this section, the computation of directional and distance codes is discussed. To calculate the directional codes, the normal vectors of points within the node are averaged. For example, if $M[t]$ is the $t^{th}$ sample point of the mesh, by adding up the normal vectors of every sample $M[t]$ within the node region, then scalar dividing by the number of samples, the average normal value is computed. Once this vector is calculated, the coordinate with the the greatest magnitude (highest absolute value), is used as the direction code for that node.

Calculating the distance codes of a node requires its directional code. From the four corners of the back-wall, rays running along the direction code are fired into the mesh, the closest intersection points are used to represent the vertices of the plane. If no intersection is found, the back-wall corner is used as the intersection point. Each distance is truncated to a range of $[-3\lambda, 3\lambda]$, where $\lambda$ is the size of the node region. To calculate intersection points, the following equation is used:

\begin{figure}[!h]
\label{RayPlaneIntersection}
$$
t = \frac{N \bullet S + D}{N \bullet V}
$$
\caption{Plane Intersection Equation.}
\end{figure}

where, $t$ is the distance, $N$ is the normal of the mesh triangle, $S$ is the basis wall corner, $D$ is the orthogonal distance from the triangle plane to the origin and $V$ is the directional code vector.

\subsection{Calculating Mean Square Error}

The $MSE$ between the fitted plane and the original mesh is calculated using the directional and distance codes. First, the plane parameters are computed from the leaf node and its directional and distance codes, then the original mesh is sampled. For each sample $M[i]$, the distance, $t$, between the plane and the mesh,  is calculated using the equation in figure \ref{RayPlaneIntersection}, where $N$ is the plane's normal, $S$ is the sample $M[i]$, $D$ is the orthogonal distance from the plane to the origin and $V$ is the normal vector of $M[i]$. This distance $t$ is then squared and summed up across all samples. Then, once all squared errors are summed, the sum is divided by the number of samples. This defines the $MSE$, which is then compared to the threshold in order to decide if a node should be split or made into a leaf node.

\subsection{Computing Decomposition}

In figure, \ref{OctreeDecompositionAlgorithm}, pseudocode is used to provide more insight into the high level operation of the SOT's decomposition. Two inputs are used, a node and the original mesh. The algorithm then proceeds into a recursive function, in which the node is split or made into a leaf depending on the $MSE$ and LOD. If it is split, this recursive function is called for each child, otherwise recursion ends. 

\definecolor{mygreen}{rgb}{0.01171875,0.3984375,0.52734375}
\definecolor{myRed}{rgb}{0.6796875,0.0078125,0.140625}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=none,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{myRed},       % keyword style
  language=Octave,                 % the language of the code
  morekeywords={*,...,},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}
\begin{figure}[!h]
\lstset{language=c++}
\begin{lstlisting}
void main():
	N = new Node() 
	M = readMesh()
	OctreeRecursiveFunction(N, M)
	
void OctreeRecursiveFunction(node, mesh):
	mse = calculateMSE(node, mesh)	//calculate MSE
	//if mesh not part of octant
	if(!node.inside(mesh)):
		return
	//if mse not low enough OR minimum node size reached
	if(mse < Threshold || node.size == MinimumSize):
		return
	for(i = 0; i < 8; i++)://for each child
		//setup child parameters
		node.child[i] = new Node()
		node.child[i].size = node.size / 2
		node.child[i].position = node.position
		switch(i):
			case 1: node.child[i].position.x += node.child[i].size
			case 2: node.child[i].position.xy += node.child[i].size
			case 3: node.child[i].position.y += node.child[i].size
			case 4: node.child[i].position.z += node.child[i].size
			case 5: node.child[i].position.xz += node.child[i].size
			case 6: node.child[i].position.xyz += node.child[i].size
			case 7: node.child[i].position.yz += node.child[i].size
		//call the recursive function for the setup child
		OctreeRecusiveFunction(node.child[i], mesh);

\end{lstlisting}
\label{OctreeDecompositionAlgorithm}
\caption{Octree Decomposition used in the SOT.}
\end{figure}

\subsection{Improving Computational Efficiency}

The SOT can be sped up by pre-computing lists of triangles which intersect a node. These triangle lists are used as search spaces for directional codes and distance codes as well as the calculation of the $MSE$. Triangles which intersect the node region can be used to calculate the $MSE$ and directional code, but distance codes require a larger triangle list. This list includes any triangle which may be required for distance code computation. Figure \ref{OctantSearchSpace} shows the search space used to calculate distance codes, the cube is the leaf region, this region and the coloured areas are the search space. This search space contains each point which has a $\lambda$-distance (Manhattan distance) of less than three times the leaf region size. All three directions are used because sub-cells do not necessarily have the same directional code as their parents.

\begin{figure}[!h]
\centering
\includegraphics[width=12cm]{images/ch2/OctantSearchSpace}
\caption{The SOT distance code search space.}
\label{OctantSearchSpace}
\end{figure}

\subsection{Progressive Transmission}

Because of its hierarchical structure, the SOT can be made into a progressive codec. To progressively transmit the SOT file, the tree, distance and directional files are transmitted in breadth-first order. As the receiver progressively decodes the tree structure it encounters leaf nodes. At each of these occurrences, directional and distance code values are sent to the decoder. At higher levels in the tree, cubes can be used to represent block regions for visualization purposes.
This not only allows the receiver to visualize the model during transmission, but also decreases the amount of time they must wait, which improves user satisfaction.



\section{Conclusion}

The SOT was designed to realize the primary goal of this research and answer the research question. In the next chapter, the experiments used to evaluate this codec are described, then results are presented and analysed in terms of the primary goal and research question.

